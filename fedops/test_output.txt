============================= test session starts ==============================
platform darwin -- Python 3.10.19, pytest-8.4.1, pluggy-1.5.0 -- /opt/homebrew/opt/python@3.10/bin/python3.10
cachedir: .pytest_cache
rootdir: /Users/sjpenn/SitesAgents/GEDSIO_Opps/fedops
plugins: asyncio-1.1.0, Faker-37.5.3, langsmith-0.4.7, timeout-2.4.0, pytest_docker_tools-3.1.9, anyio-4.10.0, cov-6.2.1, celery-1.2.1, mock-3.14.1, requests-mock-1.12.1
asyncio: mode=strict, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/test_partner_service.py::test_analyze_capability_gaps FAILED       [100%]

=================================== FAILURES ===================================
_________________________ test_analyze_capability_gaps _________________________

partner_service = <fedops_core.services.partner_service.PartnerService object at 0x11e9184c0>
mock_db = <AsyncMock id='4807820096'>

    @pytest.mark.asyncio
    async def test_analyze_capability_gaps(partner_service, mock_db):
        # Mock data
        opp_id = 1
        team_id = 1
    
        # Mock Proposal and Requirements
        mock_proposal = Proposal(id=100, opportunity_id=opp_id)
        mock_reqs = [
            ProposalRequirement(id=1, proposal_id=100, requirement_text="Must have experience with Custom Computer Programming"),
            ProposalRequirement(id=2, proposal_id=100, requirement_text="Requires Cloud Computing expertise")
        ]
    
        # Mock Team Members
        mock_members = [
            TeamMember(id=1, team_id=team_id, entity_uei="UEI1", role="PRIME"),
            TeamMember(id=2, team_id=team_id, entity_uei="UEI2", role="SUB")
        ]
    
        # Mock Entities
        entity1 = Entity(uei="UEI1", capabilities=[{"code": "541511", "description": "Custom Computer Programming"}])
        entity2 = Entity(uei="UEI2", capabilities=[{"code": "541512", "description": "Computer Systems Design"}])
    
        # Setup mock returns
        # 1. Get Proposal
        mock_db.execute.side_effect = [
            MagicMock(scalars=lambda: MagicMock(first=lambda: mock_proposal)), # Proposal
            MagicMock(scalars=lambda: MagicMock(all=lambda: mock_reqs)),      # Requirements
            MagicMock(scalars=lambda: MagicMock(all=lambda: mock_members)),    # Team Members
            MagicMock(scalars=lambda: MagicMock(first=lambda: entity1)),       # Entity 1
            MagicMock(scalars=lambda: MagicMock(first=lambda: entity2)),       # Entity 2
        ]
    
        # Run analysis
>       result = await partner_service.analyze_capability_gaps(team_id, opp_id)

tests/test_partner_service.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fedops_core.services.partner_service.PartnerService object at 0x11e9184c0>
team_id = 1, opportunity_id = 1

    async def analyze_capability_gaps(self, team_id: int, opportunity_id: int) -> Dict[str, Any]:
        """
        Compare team capabilities against opportunity requirements.
        Returns a gap analysis report.
        """
        # 1. Get Opportunity Requirements
        req_result = await self.db.execute(
            select(ProposalRequirement).where(ProposalRequirement.proposal_id == opportunity_id) # Note: assuming proposal_id maps to opp_id logic or we need to join
        )
        # Wait, ProposalRequirement links to Proposal, not Opportunity directly.
        # We need to find the proposal for this opportunity, or if we are in early stage,
        # maybe we use extracted requirements from the opportunity directly (if stored elsewhere).
        # For now, let's assume we have a proposal or we fetch requirements associated with the opportunity.
    
        # Let's fetch the proposal first
        from fedops_core.db.models import Proposal
        prop_result = await self.db.execute(select(Proposal).where(Proposal.opportunity_id == opportunity_id))
        proposal = prop_result.scalars().first()
    
        requirements = []
        if proposal:
            req_result = await self.db.execute(
                select(ProposalRequirement).where(ProposalRequirement.proposal_id == proposal.id)
            )
            requirements = req_result.scalars().all()
    
        # 2. Get Team Capabilities
        team_result = await self.db.execute(
            select(TeamMember).where(TeamMember.team_id == team_id)
        )
        members = team_result.scalars().all()
    
        team_capabilities = []
        for member in members:
            # Fetch entity to get full capabilities
            entity = await self.get_entity_profile(member.entity_uei)
            if entity and entity.capabilities:
                for cap in entity.capabilities:
                    team_capabilities.append({
                        "source": member.entity_uei,
                        "role": member.role,
                        "capability": cap
                    })
    
        # 3. Match Requirements to Capabilities (Simple Keyword Matching for now)
        # In a real system, this would use embeddings/semantic search
        coverage = []
        uncovered = []
    
        for req in requirements:
            matches = []
>           req_text = req.requirement_text.lower()
E           AttributeError: 'TeamMember' object has no attribute 'requirement_text'

fedops_core/services/partner_service.py:196: AttributeError
=============================== warnings summary ===============================
../../../../../opt/homebrew/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../../../opt/homebrew/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../../../opt/homebrew/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../../../opt/homebrew/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../../../opt/homebrew/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../../../opt/homebrew/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../../../opt/homebrew/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../../../opt/homebrew/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
../../../../../opt/homebrew/lib/python3.10/site-packages/pydantic/_internal/_config.py:323
  /opt/homebrew/lib/python3.10/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

fedops_api/main.py:50
  /Users/sjpenn/SitesAgents/GEDSIO_Opps/fedops/fedops_api/main.py:50: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../../../opt/homebrew/lib/python3.10/site-packages/fastapi/applications.py:4495
  /opt/homebrew/lib/python3.10/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_partner_service.py::test_analyze_capability_gaps - Attribut...
======================== 1 failed, 11 warnings in 0.19s ========================
